#### Part1.0 假设

如果一个节点或者网页被其它重要的节点或者网页链接了，那么这个网页就是重要的,pagerank主要是根据节点之间的转移概率来衡量一个节点或者网页的重要性。



#### Part2.0 来由

早期的搜索引擎是根据关键字检索是是不考虑网页的质量的，如果一个网页中包含某个关键字越多的话，那么越容易被检索到，这样就会造成网页的作弊以及大量的为了提高被检索到但是内容却很low的低质量网站。总结一下

1. 返回结果质量不高：搜索结果不考虑网页的质量，而是通过时间顺序进行检索；
2. 容易被人钻空子：搜索引擎是基于检索词进行检索的，页面中检索词出现的频次越高，匹配度越高，这样就会出现网页作弊的情况。有些网页为了增加搜索引擎的排名，故意增加某个检索词的频率。

基于这些缺陷，当时 Google 的创始人拉里·佩奇提出了 PageRank 算法，目的就是要找到优质的网页，这样 Google 的排序结果不仅能找到用户想要的内容，而且还会从众多网页中筛选出权重高的呈现给用户。其灵感就是论文影响力因子的启发。

#### Part3.0 简化模型

![img](https://pic3.zhimg.com/v2-716e9607cdfaca7341c56d0b3e53345a_b.jpg)

前置知识

> 出度:一个节点的出度指由该节点出发指向其它节点的边的数量。
>
> 入度:一个节点的入读是指从其它节点出发指向该节点的边的数量

如何理解一个节点的重要度呢？或者说如何表示一个节点的重要度

> 1.如果一个商品被大量购买或者一家店被很多人关顾，我们就知道这个商品或者这家店就很多，从入度角度看，有很多条边指向该商品或者这家店。
>
> 2.从出度角度理解一个节点的重要性。比如说一个大牛，那么该大牛的朋友也会因为认识该大牛而被认为也是一个不错的人。这就是该节点对其它节点的影响力或者对其它节点影响力的贡献。

在pagerank中，一个节点的重要度通过pagerank值进行表示:
$$
PR(u) = \sum_{v \in out(v)}\frac{PR(v)}{L(v)}
$$
其中$out(v)$表示指向u的顶点集合，L(V)为顶点V的出度，PR(V)为顶点V的Pagerank值，从以上公式我们可以知道，一个顶点的pagerank值可以为所有指向该顶点的pr值的加权求和。所以你能看到，出链会给被链接的页面赋予影响力，当我们统计了一个网页链出去的数量，也就是统计了这个网页的跳转概率。

> ★  在这个例子中，你能看到 A 有三个出链分别链接到了 B、C、D 上。那么当用户访问 A 的时候，就有跳转到 B、C 或者 D 的可能性，跳转概率均为 1/3。
>
> B 有两个出链，链接到了 A 和 D 上，跳转概率为 1/2。
>
> 这样，我们可以得到 A、B、C、D 这四个网页的转移矩阵 M： 

![img](https://pic3.zhimg.com/v2-577a16d30f0b17fd4b487486bb6b3be2_b.jpg)

这个转移矩阵的每一列表示每一个顶点对其它页面的贡献度(也就是从该顶点跳转到其它顶点的概率)，矩阵的每一行表示其它顶点跳转到我这里的概率。

有了这个转移矩阵，我们就可以计算每个页面的影响力是多少了。

> ★  比如上图A页面的影响力怎么计算呢？ 其实我们是通过他的入链点B、C的影响力去计算的，也就是我们的那个公式。 开始我们假设四个页面的影响力相同，都是1/4。 则A第一次的影响力这么想，B有两条出链，那么会给我传过它影响力的1/2。 C有一条出链，那么会把它的影响力全传给A。
> 故： PR(A) = 1/4 * 1/2 + 1/4
> 这是一次迭代。你发现了吗？ 这其实就是转移矩阵M的第一行 * 一个全为1/4的列向量得到的（向量乘法）
>  ”

所以如果我们利用向量的乘法原理的话，只需要一个向量乘法就可以计算出每个页面的影响力了。

我们假设 A、B、C、D 四个页面的初始影响力都是相同的，即： 

![img](https://pic3.zhimg.com/v2-457d84df134ba11764af29eceb51404a_b.png)

 当进行第一次转移之后，各页面的影响力 w1 变为： 

![img](https://pic4.zhimg.com/v2-2207407d2f7afb47357d0dba59f00497_b.jpg)

 然后我们再用转移矩阵乘以 w1 得到 w2 结果，直到第 n 次迭代后 wn 影响力不再发生变化，可以收敛到 (0.3333，0.2222，0.2222，0.2222），也就是对应着 A、B、C、D 四个页面最终平衡状态下的影响力

上面对应的情况都是一个节点既有出链同时也有入链的时候，当一个节点只有入链没有出链或者一个节点只有出链没有入链的时候会发生什么呢？

##### 等级泄露（Rank Leak）：如果一个网页没有出链，就像是一个黑洞一样，吸收了其他网页的影响力而不释放，最终会导致其他网页的 PR 值为 0

![img](https://pic1.zhimg.com/v2-df17439fe18fd1eeedf9668a92ca8e70_b.jpg)

##### 等级沉没（Rank Sink）：如果一个网页只有出链，没有入链（如下图所示），计算的过程迭代下来，会导致这个网页的 PR 值为 0（也就是不存在公式中的 V）。

![img](https://pic2.zhimg.com/v2-56690a79a3a09729110b7d3bb52bc041_b.jpg)

两个列子来帮助理解

> 1.等级泄露(节点只有入链，但是没有出链)，比如练武，如果一个人在不停的接受别人传给他的功力，而不回传功力给其它人，那么这个人到最后肯定是一个武林高手，但是其它人可能因为一直在传功给他而导致武功慢慢衰退。
>
> 2.等级沉没(节点只有出链，但是没有入链)如果一个人只往外传功力，不接收外来人的功力，比如给人疗伤的时候，那么这个人很快也就会功力丧失了。（武侠小说中疗伤的时候，某个大侠给人疗着疗着自己就昏过去了）

## Part4.0 PageRank 的随机浏览模型

为了解决简化模型中存在的等级泄露和等级沉没的问题，拉里·佩奇提出了 PageRank 的随机浏览模型。他假设了这样一个场景：用户并不都是按照跳转链接的方式来上网，还有一种可能是不论当前处于哪个页面，都有概率访问到其他任意的页面，比如说用户就是要直接输入网址访问其他页面，虽然这个概率比较小。

所以他定义了阻尼因子 d，这个因子代表了用户按照跳转链接来上网的概率，通常可以取一个固定值 0.85，而 1-d=0.15 则代表了用户不是通过跳转链接的方式来访问网页的(随机重启的概率)，比如直接输入网址。 
$$
PR(u) = \frac{1-d}{N}+d\sum_{v \in in(u)}\frac{PR(v)}{LV(v)}
$$
 其中 N 为网页总数，这样我们又可以重新迭代网页的权重计算了，因为加入了阻尼因子 d，一定程度上解决了等级泄露和等级沉没的问题。

通过数学定理（这里不进行讲解）也可以证明，最终 PageRank 随机浏览模型是可以收敛的，也就是可以得到一个稳定正常的 PR 值。

## Part5.0  Personal PageRank

### 1、个性化召回算法Personal Rank背景与物理意义

1、首先介绍基于图的个性化召回算法—personal rank的背景。

（1）用户行为很容易表示为图

图这种数据结构有两个基本的概念—顶点和边。

在实际的个性化推荐系统中，无论是信息流场景、电商场景或者是O2O场景，用户无论是点击、购买、分享、评论等等的行为都是在user和item两个顶点之间搭起了一条连接边，构成了图的基本要素。

实际上这里user与item构成的图是二分图，后面会介绍二分图的概念以及结合具体的例子展示如何将用户行为转换为图。

（2）图推荐在个性化推荐领域效果显著

2、二分图
二分图又称为二部图，是图论中的一种特殊模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集（A,B），并且图中的每条边（i,j）所关联的两个顶点 i 和 j 分别属于这两个不同的顶点集（i in A, j in B）,则称图G为一个二分图。

（如果有一种无向图，它的定点可以分成两个独立的集合，并且互不相交，且所有的边关联顶点，都从属于这个集合。那么这样的图可以称为二分图。）

则，推荐系统中，user、item恰好满足两种独立的集合，并且用户行为总是从user顶点到item顶点集合，所以由推荐系统中user和item之间构成的图就是二分图。

接下来结合具体实例讲解如何将用户的行为转化为二分图。

假设某推荐系统中有4个用户：A B C D，以及从日志（log）中发现对如下item有过行为：

![](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第03章基于图的个性化推荐召回算法PersonalRank/1564726845935.png)

即：user A 对 item a、b、d有过行为，userB 对 item a、c有过行为，userC对 item b、e有过行为，userD 对 item c、d有过行为。

首先将user、item分成两组不相交的集合，如下：

[![1564726875995](https://enfangzhong.github.io/2019/06/01/%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC03%E7%AB%A0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E5%8F%AC%E5%9B%9E%E7%AE%97%E6%B3%95PersonalRank/1564726875995.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第03章基于图的个性化推荐召回算法PersonalRank/1564726875995.png)

然后，将所有user 对 item 有过行为的进行连线，就可以得到二分图，

如下：

![image-20200926101605651](/Users/eason/Library/Application Support/typora-user-images/image-20200926101605651.png)

此时问题也就抽象出来了，对于userA 来说，item c 和item e哪个更值得推荐？

这里共有5个item，其中userA 已经对item a、b、d有过行为，这里行为是指信息流产品中的点击或者电商产品中的购买等表示user对item喜欢的这种操作。

那么personal rank恰恰是这么一种算法，它能够结合用户行为构成的二分图，对于固定用户对item集合的重要程度给出排序，也就是说将user A 没有对item c 和item e有过行为，但是personal rank算法可以给出item c 和item e对于user A来说，哪个更值得推荐。

下面从物理意义的角度来分析一下，从二分图上如何分析出来item集合对user的重要程度3、物理意义
（1）两个顶点之间连通的路径数

如果要比较两个item顶点对固定user的重要程度，只需分别看一下user到两个item顶点的路径数，路径数越多的顶点越重要。

（2）两个顶点之间连通的路径长度

同样路径数的情况下，总路径长度越短的顶点越重要。

（3）两个顶点之间连通路径经过顶点的出度

这里解释一下出度的概念：出度是指顶点对外连接边的数目。如user A对item a、b、d有过行为，即为有条连接边，则A的出度为3。如果前两项都相同，则两个item对固定user 的重要程度则比较经过顶点所有的出度和，如果出度和越小则越重要。

结合刚才所举的具体二分图的例子，给大家介绍—对于user A来说，item c 和item e哪个更值得推荐？

### 2、Personal Rank算法example解析

例子分析

[![1564729370493](https://enfangzhong.github.io/2019/06/01/%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC03%E7%AB%A0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E5%8F%AC%E5%9B%9E%E7%AE%97%E6%B3%95PersonalRank/1564729370493.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第03章基于图的个性化推荐召回算法PersonalRank/1564729370493.png)

1.分别有几条路径连通？

首先看A-c 之间有几条路径连通：分别是A-a-B-c，A-d-D-c 两条路径连通。

再来看A-e 之间有几条路径连通：A-b-C-e一条路径

从这一角度出发，可以知道 c 比 e 重要。

2.连通路径的长度分别是多少？

首先看A-c 之间有几条路径连通：分别是A-a-B-c，A-d-D-c ，长度都为3

再来看A-e 之间有几条路径连通：A-b-C-e长度为3

3.连通路径的经过顶点出度分别是多少?

首先看A-a-B-c这条路径：A出度是3，a出度是2，B出度是2，c出度是2

再看A-d-D-c这条路径：A出度是3，d出度是2，D出度是2，c出度是2

再看A-b-C-e这条路劲：A出度是3，b出度是2，C出度是2，e出度是1

实例中这里我们物理意义得到的结果。接下来使用程序来完成person Rank算法的时候同样可以得到相同的结论。

虽然 e 的出度和更小，但是由于1中 c 有两条路径，且1的优先级更高，所以还是应该推荐 c。

### 3、Personal Rank算法公式解析

personal rank是可以通过用户行为划分二分图为固定user得到item重要程度排序的一种算法。

1.算法的文字阐述

随机游走算法PersonalRank实现基于图的推荐对用户A进行个性化推荐，从用户A节点开始在用户-物品二分图random walk，以alpha的概率从A的出边中，等概率选择一条游走过去，到达该顶点后（举例顶点a），由alpha的概率继续从顶点a的出边中，等概率选择一条继续游走到下一个节点，或者（1-alpha）的概率回到顶点A，多次迭代。直到各顶点对于用户A的重要度收敛。

[![1564729376053](https://enfangzhong.github.io/2019/06/01/%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC03%E7%AB%A0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E5%8F%AC%E5%9B%9E%E7%AE%97%E6%B3%95PersonalRank/1564729376053.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第03章基于图的个性化推荐召回算法PersonalRank/1564729376053.png)

后续我们在实现person rank算法的时候用不同的alpha值来做实验，熟悉是Google的pageRank算法的童鞋们可以发现PageRank与person rank算法有极大的相似性。只不过PageRank算法没有固定的起点。

2.算法的数学公式

![](/Volumes/disk2/Basic-Algorithm/picture/personpagerank.png)

把不同item对user的重要程度描述为PR值。

为了便于理解，同样适用A作为固定起点。user A的PR值初始化为1，其余节点的PR值初始化为0。

这里使用 a 节点和 A 节点阐述公式的上半部分和公式的下半部分：

首先看公式的上部分，根据person rank的算法描述，节点a只可能是节点A与节点B,以alpha概率从他们的出边中等概率的选择了与节点a相互连的这条边。

具体来看，从user A出发有3条边，以3条边中等概率的选择了节点a连接的这条边，以1/3的概率选择连接节点a；user B以1/2的概率选择了连接节点a。

结合阐述看一下公式的上半部分：对于不是A节点的PR值，也就是 a 的PR值，那么首先要找到连接该顶点节点，同时分别计算他们PR值得几分之几贡献到要求节点的PR值。那么A将自己PR值得1/3贡献给了 a ，B将自己PR值得1/2贡献给了 a，分别求和，乘alpha，得到 a 的PR值。

接下来看下半部分：如果要求A节点本身的PR值，首先知道任意节点都会以（1-alpha）的概率回到本身，那么对于一些本来就与A节点相连的节点，比如这里的 a 节点或者 b 节点，它们除了以（1-alpha）的概率直接回到A以外；还可以以alpha的概率从自己的出边中等概率的选择与A相邻的这条边，比如这里的 a 节点，可以以1/2的概率选择回到A节点，所以就构成了下半部分的前后两个部分。

经过分析可以发现，personal rank算法求item对固定user的PR值，需要每次迭代在全图范围内迭代，时间复杂度在工业界实际算法落地的时候是不能接受的，所以要让尽可能多的user并行迭代。结合之前许多其他算法训练的工业界实现，很容易想到矩阵化实现，下面看personal rank算法的矩阵化实现。

3.算法抽象—矩阵式

$r=(1-\alpha) r_{0}+\alpha M^{T} r$

$M_{i j}=\frac{1}{|o u t(i)|} j \in \operatorname{out}(i) e l s e 0$

假设这里共有m个user，n个item。

R矩阵是m+n行，1列矩阵，表示其余顶点对该固定顶点的PR值。当然得到了这个，就得到了固定顶点下，其余所有顶点的重要程度排序，这里只需要排出m个user节点。只看n个item节点对该固定顶点的排序。也就得到了该固定顶点下推荐的item。

r0 是m+n行，1列的矩阵，负责选取某一节点是固定节点，它的数值只有1行唯一，其余行全为0。唯一的行，即为选取了该行对应的顶点为固定顶点。那么得到的就是该固定顶点下，其余节点对该固定节点的重要程度的排序。

M 是 m+n行 * m+n列的矩阵，也就是行包含了所有的节点，列也包含了所有的节点。 它是转移矩阵，数值定义如下：1.第一行第二列的数值距离，如果第一行对应的数值顶点由出边连接到了第二列的顶点，那么该值就为第一行顶点的出度的倒数；如果没有连接边，那么就是0。

我们很容易联想到，第一个式子包含了刚才所说的非矩阵化的personal rank的公式的上下两部分。

上述公式是本部分中第一个公式，移项、合并同类项之后得到的。

该公式是上一公式两个同时乘以$\left(E-\alpha M^{T}\right)$转置的之后得到的。

刚才说过，r0是m+n行，1列的矩阵，它能够选取固定的顶点，得到固定顶点的推荐结果。如果将r0变为（m+n）*（m+n）的矩阵，也就得到了所有顶点的推荐结果。

由于得到的推荐结果是考虑顶点之间的PR值的顺序关系，并非一个绝对数值，所以可以将$(1-\alpha) $舍去。所以$\left(E-\alpha M^{T}\right)^{-1}$即为所有顶点的推荐结果。每一列表示该顶点下，其余顶点对于该顶点的PR值。

但是，需要注意的是，每一个user能够行为的item毕竟是少数，所以这里的M矩阵是稀疏矩阵，$\left(E-\alpha M^{T}\right)^{-1}$同样也是稀疏矩阵。

### 4. 迭代代码

![image-20200926111332667](/Users/eason/Library/Application Support/typora-user-images/image-20200926111332667.png)

因为personpagerank求得是想对于固定点其他顶点的重要程度，在max_step的迭代次数中，求解一个顶点就需要$n^2$的时间复杂度。这在时间复杂度是无法接受的。因此一般在应用的时候都会通过装换为矩阵的形式进行求解。

矩阵形式推导见下图中，最后结果行由于推荐是求的结点的相对重要性，所以在实际计算中1-alpha可以省略，（E－alpha＊M.tranpose()) 的逆矩阵即为所有结点推荐结果的。每一列表示一个结点的结果（如果该矩阵为n＊n）。r0 即为n＊1矩阵，且只有一行为1，其余为0，想取出第几个结点的结果就将第几行赋值为1.

![image-20200926112147761](/Users/eason/Library/Application Support/typora-user-images/image-20200926112147761.png)

