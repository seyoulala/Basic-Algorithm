### 初级班第八课



```一块金条切成两半， 是需要花费和长度数值一样的铜板的。 比如
长度为20的金条， 不管切成长度多大的两半， 都要花费20个铜板。 一群人想整分整块金 条， 怎么分最省铜板？
例如,给定数组{10,20,30}， 代表一共三个人， 整块金条长度为10+20+30=60. 金条要分成10,20,30三个部分。 如果， 先把长度60的金条分成10和50， 花费60 再把长度50的金条分成20和30，花费50 一共花费110铜板。但是如果， 先把长度60的金条分成30和30， 花费60 再把长度30金条分成10和20， 花费30 一共花费90铜板。输入一个数组， 返回分割的最小代价。 
```

**解法：哈夫曼编码(贪心策略),核心思想：子节点合并的代价是子节点值相加的和**

如下图所示:

![](..\image\哈夫曼树.png)

将10,20,30利用哈夫曼编码合并的最小代价为非叶节点的值相加。则最小代价为30+60=90.那么从上到下看，将60切分成三段的最小代价的切割方法为。1.首先将60分为30,30两段，然后将30分为20,10两段。因此这道题的求解思路就是哈夫曼编码合并的逆过程。

那么哈夫曼树是如何构建的呢？构建步骤如下：

1. 首先使用数组构建一个小根堆
2. 每次从小根堆中取出两个最小值a,b将a,b相加得到合并代价c
3. 将c放入小跟堆中，重新构建一个小根堆
4. 重复2,3直到堆中只有一个值停止
5. 将所有的c累加得到总体的合并代价

```java
import  java.util.Comparator;
import java.util.PriorityQueue;

public class Code_02_Less_Money {

	public static int lessMoney(int[] arr) {
		PriorityQueue<Integer> pQ = new PriorityQueue<>();
		for (int i = 0; i < arr.length; i++) {
			pQ.add(arr[i]);
		}
		int sum = 0;
		int cur = 0;
		while (pQ.size() > 1) {
			cur = pQ.poll() + pQ.poll();
			sum += cur;
			pQ.add(cur);
		}
		return sum;
	}

	public static class MinheapComparator implements Comparator<Integer> {

		@Override
		public int compare(Integer o1, Integer o2) {
			return o1 - o2; // < 0  o1 < o2  负数
		}

	}

	public static class MaxheapComparator implements Comparator<Integer> {

		@Override
		public int compare(Integer o1, Integer o2) {
			return o2 - o1; // <   o2 < o1
		}

	}

	public static void main(String[] args) {
		// solution
		int[] arr = { 6, 7, 8, 9 };
		System.out.println(lessMoney(arr));

		int[] arrForHeap = { 3, 5, 2, 7, 0, 1, 6, 4 };

		// min heap
		PriorityQueue<Integer> minQ1 = new PriorityQueue<>();
		for (int i = 0; i < arrForHeap.length; i++) {
			minQ1.add(arrForHeap[i]);
		}
		while (!minQ1.isEmpty()) {
			System.out.print(minQ1.poll() + " ");
		}
		System.out.println();

		// min heap use Comparator
		PriorityQueue<Integer> minQ2 = new PriorityQueue<>(new MinheapComparator());
		for (int i = 0; i < arrForHeap.length; i++) {
			minQ2.add(arrForHeap[i]);
		}
		while (!minQ2.isEmpty()) {
			System.out.print(minQ2.poll() + " ");
		}
		System.out.println();

		// max heap use Comparator
		PriorityQueue<Integer> maxQ = new PriorityQueue<>(new MaxheapComparator());
		for (int i = 0; i < arrForHeap.length; i++) {
			maxQ.add(arrForHeap[i]);
		}
		while (!maxQ.isEmpty()) {
			System.out.print(maxQ.poll() + " ");
		}

	}

}

```

```python
import heapq
#堆
def lessmoney(array):
    # 首先将array构建成一个堆，也就是将list转换为等价的优先级队列
    heapq.heapify(array)
    total_cust = 0
    cur = 0
    while len(array) > 1:
        # 弹出两个最小的
        cur = heapq.heappop(array) + heapq.heappop(array)
        total_cust += cur
        # 将累计值继续放入堆中
        heapq.heappush(array, cur)
    return total_cust

##优先级队列(本质也是heapq的实现)
def lessMoney(array):
    pq = PriorityQueue()
    for i in array:
        pq.put(i)
    total_sum = 0
    cur = 0
    while pq.qsize() > 1:
        cur = pq.get() + pq.get()
        total_sum += cur
        pq.put(cur)
    return total_sum


if __name__ == "__main__":
    li = [10, 20, 30]
    print(lessmoney(li))
```



**本质上也是贪心策略，每次从小跟堆中取出两个最小的**



```
输入：参数1 正数数组costs，参数数组 profits ,参数3 正数K，参数4，正数m
costs[i]表示i号项目的花费 profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润) k表示你不能并行、 只能串行的最多做k个项目 m表示你初始的资金.

说明： 你每做完一个项目， 马上获得的收益， 可以支持你去做下一个项目(每次只能做一个项目)
求输出：最后获得的最大钱数
```

求解方法:**贪心策略,每次从能做的项目中选择收益最高的项目做，按照这个策略做K个项目，那么此时总共的收益是最高的**

![](..\image\项目.png)



求解步骤如下：

1. 首先将所有的项目放入小跟堆中(图中红色箭头)，小根堆的堆顶是花费最低的项目
2. 将小跟堆中所有花费小于初始资金m的项目弹入到大根堆(图中绿色箭头)，大根堆的堆顶是收益最高的项目
3. 弹出大根堆堆顶的项目，计算项目收益，更新初始资金
4. 重复步骤2,3知道做了K个项目结束或者启动资金不足
5. 输出最后的最大累积收益

```java

import java.util.Comparator;
import java.util.PriorityQueue;

/*
项目问题
*/

public class Code_03_IPO {
	public static class Node {
		public int p;
		public int c;

		public Node(int p, int c) {
			this.p = p;
			this.c = c;
		}
	}

	public static class MinCostComparator implements Comparator<Node> {

		@Override
		public int compare(Node o1, Node o2) {
			return o1.c - o2.c;
		}

	}
	public static class MaxProfitComparator implements Comparable<Node>{
		@Override
		public int compare(Node o1,Node o2){
			return o2.p - o1.p;
		}
	}

 
	public static int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {
		Node[] nodes = new Node[Profits.length];
		for (int i = 0; i < Profits.length; i++) {
			nodes[i] = new Node(Profits[i], Capital[i]);
		}
		//花费低的小根堆
		PriorityQueue<Node> minCostQ = new PriorityQueue<>(new MinCostComparator());
		//收益高的大根堆
		PriorityQueue<Node> maxProfitQ = new PriorityQueue<>(new MaxProfitComparator());
		for (int i = 0; i < nodes.length; i++) {
			minCostQ.add(nodes[i]);
		}
		for (int i = 0; i < k; i++) {
			while (!minCostQ.isEmpty() && minCostQ.peek().c <= W) {
				maxProfitQ.add(minCostQ.poll());
			}
			if (maxProfitQ.isEmpty()) {
				return W;
			}
			W += maxProfitQ.poll().p;
		}
		return W;
	}
}

```

```python
class Node:
	def __init__(self, c, p):
		self.c = c
		self.p = p

class Solution:
	def findMaxCaptial(self, k, w, profits, capital):
		# 生成所有的项目
		nodes = []
		for p, c in zip(profits, capital):
			nodes.append(Node(c, p))
		# 生成按照花费谁小谁在堆顶的小跟堆
		mincostQ = sorted(nodes, key=lambda x: x.c)

		#将花费小于启动资金的项目加入到大根堆中
		maxprofitQ=[]

		#开始做项目，直到做满K个项目或者启动资金不足为止
		for i in range(k):
			while len(mincostQ)!=0 and mincostQ[0].c<w:
				maxprofitQ.append(mincostQ.pop(0))
			maxprofitQ = sorted(maxprofitQ,key=lambda x:x.p,reverse=True)
            ##大根堆空了，说明没有项目可做了
			if len(maxprofitQ)==0:
				return w
			w+=maxprofitQ.pop(0).p
		return  w

if __name__ =="__main__":
	pro_list =[5,10,30]
	cost_list =[10,20,100]
	s = Solution()
	lastmoney = s.findMaxCaptial(3,100,pro_list,cost_list)
	print(lastmoney)

```

