#### 什么是贪心算法？

贪心算法可以认为是动态规划的一种特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。

比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。

什么是贪心选择性质呢？简单来说就是每一步都做出一个局部最优的选择，最终的结果就是全局最优。

比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。

但是现实生活中，有很多问题并不具备贪心选择性质。

**区间调度问题**

```
给你一个array，array中的元素是[start,end]的区间，现在问你，array中最多有几个不重叠的区间？边界相同不算重叠
比如[[1,3],[2,3],[3,4]].
不重叠的区间为[[1,3],[3,4]]或者[[2,3],[3,4]]，最多有2个不重叠的区间。
```

区间调度问题是一个很典型的贪心问题。相同的问题还有`最多能参加几个活动`，把start换为起始时间，end换为终止时间，问你你一天最多能参加几个活动?

既然是一个贪心问题，我们的贪心策略是如何的呢？既我们在每一步要如何做选择才能得到局部的最优？比如我们可以尝试几种策略：

1.每次选择最早的活动去参加。问题是活动虽然可能开始的比较早，但是如果持续的很长时候的话，那么很错容易过很多其它时间比较短的活动。

2.每次选择区间长度最小的那个活动去参加。但是这个问题就是虽然你活动持续时间段，但是你可能开始时间很晚，那么就会错过之前的一些活动。



正确的贪心策略是：1.首先我们将区间按照结束时间end进行升序排序。2.然后选择剩余区间和当前区间没有重叠的区间。3重复1、2直到所有可能区间都选择过了，那么选出来的区间就是最大的不重叠的区间。

<img src="/Users/eason/Library/Application%20Support/typora-user-images/image-20201215201639224.png" alt="image-20201215201639224" style="zoom:50%;" />

#### 例题

**无重叠区间**

```
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:
可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
示例 1:

输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
示例 2:

输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
示例 3:

输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。

```

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals)==0:
            return 0
        intervals = sorted(intervals,key=lambda x:x[1])
        count=1
        end = intervals[0][1]
        for i in range(1,len(intervals)):
            if intervals[i][0]>=end:
                end = intervals[i][1]
                count+=1
        return  len(intervals)-count
```

