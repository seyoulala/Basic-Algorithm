 暴力递归

1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件(base case)
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解

### 动态规划

1. 从暴力递归中来
2. 将每一个子问题的解记录下来，**避免重复计算**
3. 把暴力递归的过程，抽象成了状态表达
4. 并且存在化简状态表达，使其更加简洁的可能





**题1**

```
打印字符串的全部子序列
```



![](..\image\字符串的子序列.png)

**思路**

每个位置都有两个决策，打印以及不打印。当前位置传递给下一个位置时，都有两条路可以走，每一次递归的时候都走两条路。



**题2**

```
母牛每年生一只母牛， 新出生的母牛成长三年后也能每年生一只
母牛， 假设不会死。 求N年后， 母牛的数量
```

![](..\image\牛生牛.png)

**思路**

列出前几年的牛出生的个数，然后找出规律。从上图中发现，从第5年开始当年母牛总的数量为$F(n)=F(n-1)+F(n-3)$

对上式的解释:因为牛不会死，所以今年的牛包含**去年的牛**以及**三年前在今年成熟的牛新生的牛**



```
给你一个二维数组， 二维数组中的每个数都是正数， 要求从左上角走到右下角， 每一步只能向右或者向下。 沿途经过的数字要累加起来。 返回最小的路径和。
```

**递归版本**

![](../image/最小路径和1.png)

从上图我们可以知道，从(0,0)位置处有两条路径可以走，向右以及向下,那么计算(0,0)位置的最短路径就需要比较(0,1)以及(1,0)处的最小路径，计算(0,1)位置的最小路径又需要知道(0,2)以及(1,1)的最小路径，计算(1,0)位置又需要知道(1,1)以及(2,0)的最小路径,从图上我们可以看到(1,1)处重复计算了，这样的重复计算是很多的，所以暴力递归很消耗时间。

```python
def minweigthsum(array,i,j):
	#如果已经到了右下角了,那么返回
	if i== len(array)-1 and j== len(array[0])-1:
		return array[i][j]
	#如果在右边界上,那么只能往下走
	elif j==len(array[0])-1:
		return array[i][j]+minweigthsum(array,i+1,j)
	#如果在最下边界，那么只能往右走了
	elif i==len(array)-1 :
		return array[i][j] + minweigthsum(array,i,j+1)
	#如果当前位置左右都能走
	else:
		right = minweigthsum(array,i,j+1)
		down = minweigthsum(array,i+1,j)
		return  array[i][j]+min(right,down)

if __name__ == '__main__':
    matrix =[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
    print(minweigthsum(matrix,0,0))
```

