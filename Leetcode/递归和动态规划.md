 暴力递归

1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件(base case)
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解

### 动态规划

1. 从暴力递归中来
2. 将每一个子问题的解记录下来，**避免重复计算**
3. 把暴力递归的过程，抽象成了状态表达
4. 并且存在化简状态表达，使其更加简洁的可能



**题1**

```
打印字符串的全部子序列
```



![](..\image\字符串的子序列.png)

**思路**

每个位置都有两个决策，打印以及不打印。当前位置传递给下一个位置时，都有两条路可以走，每一次递归的时候都走两条路。



**题2**

```
母牛每年生一只母牛， 新出生的母牛成长三年后也能每年生一只
母牛， 假设不会死。 求N年后， 母牛的数量
```

![](..\image\牛生牛.png)

**思路**

列出前几年的牛出生的个数，然后找出规律。从上图中发现，从第5年开始当年母牛总的数量为$F(n)=F(n-1)+F(n-3)$

对上式的解释:因为牛不会死，所以今年的牛包含**去年的牛**以及**三年前在今年成熟的牛新生的牛**

**题目3**

```
给你一个二维数组， 二维数组中的每个数都是正数， 要求从左上角走到右下角， 每一步只能向右或者向下。 沿途经过的数字要累加起来。 返回最小的路径和。
```

**递归版本**

![](../image/最小路径和1.png)

从上图我们可以知道，从(0,0)位置处有两条路径可以走，向右以及向下,那么计算(0,0)位置的最短路径就需要比较(0,1)以及(1,0)处的最小路径，计算(0,1)位置的最小路径又需要知道(0,2)以及(1,1)的最小路径，计算(1,0)位置又需要知道(1,1)以及(2,0)的最小路径,从图上我们可以看到(1,1)处重复计算了，这样的重复计算是很多的，所以暴力递归很消耗时间。

```python
def minweigthsum(array,i,j):
	#如果已经到了右下角了,那么返回
	if i== len(array)-1 and j== len(array[0])-1:
		return array[i][j]
	#如果在右边界上,那么只能往下走
	elif j==len(array[0])-1:
		return arra	y[i][j]+minweigthsum(array,i+1,j)
	#如果在最下边界，那么只能往右走了
	elif i==len(array)-1 :
		return array[i][j] + minweigthsum(array,i,j+1)
	#如果当前位置左右都能走
	else:
		right = minweigthsum(array,i,j+1)
		down = minweigthsum(array,i+1,j)
		return  array[i][j]+min(right,down)

if __name__ == '__main__':
    matrix =[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
    print(minweigthsum(matrix,0,0))
```

**改为动态规划**

![](../image/dp1.png)



转换步骤如下：

假如递归函数中可变参数是二维的,那么dp表就是一个二维的表，将递归改为动态规划

1. 首先要在dp表中找到需要求解的点如上图坐上角的点，然后确定递归函数中basecase，也就是右下角的点。
2. 根据递归函数确定dp表中不被依赖的位置,上图中的下边界和右边界
3. 回到递归中，分析一个普遍位置的依赖关系。



```python
def minweightsum2(array):
	if len(array) == 0 or len(array[0]) == 0:
		return 0
	rows = len(array)
	cols = len(array[0])
	# 构建一个dp二维表
	dp = [[0] * cols for i in range(rows)]
	# 首先将dp表中不被依赖的位置填好
	dp[rows - 1][cols - 1] = array[rows - 1][cols - 1]
	for i in range(rows - 1)[::-1]:
		dp[i][cols - 1] = array[i][cols - 1] + dp[i + 1][cols - 1]
	# 最下面一列
	for j in range(cols - 1)[::-1]:
		dp[rows - 1][j] = array[rows - 1][j] + dp[rows - 1][j + 1]
	#对于普遍位置
	for i in range(rows-1)[::-1]:
		for j in range(cols-1)[::-1]:
			dp[i][j]=array[i][j] + min(dp[i+1][j],dp[i][j+1])
	return  dp[0][0]
```



**题目4**

```
给你一个数组arr， 和一个整数aim。 如果可以任意选择arr中的数字， 能不能累加得到aim， 返回true或者false
```

**递归版本**

![](..\image\数组累加递归.png)



对于数组中任意一个位置，去往下个位置都有两种选择，累加当前位置数字以及不累加当前数字，若当前位置已经在终止位置的时候，若出现过累加和等于aim,那么返回True,否则返回False

```python
def isSum(array,i,sum,aim):
	if len(array)==0 or aim is None:
		return False
	length = len(array)
    ##basecase
	if i==length:
		return sum==aim
	return  isSum(array,i+1,sum,aim) or isSum(array,i+1,sum+array[i],aim)

```

**改为动态规划**

![](..\image\数组累加dp.png)



从递归函数中我们可以知道，在终止位置时候只有sum==aim才会返回True，其它都是False,最后一行的我们可以填充进去值，然后对于图中的**普遍位置L**，从递归函数中可以清楚L依赖两个位置的结果,(i+1,sum)以及(i+1,sum+array[i])处的状态.·`dp[i][j]`表示i位置之前的数能否累加到j

```python
def isSum(array, aim):
    if len(array) == 0 or aim is None:
        return False
    # 创建一个二维表
    #累加和肯定不会大于array中所有数相加
    array_sum = sum(array)
    length = len(array)
    dp = [[False] * (array_sum+1) for i in range(length + 1)]
    dp[length][aim] = True
    for i in range(length)[::-1]:
        for j in range(array_sum+1)[:-1]:
            dp[i][j] = dp[i + 1][j]
            if j + array[i] <= aim:
                dp[i][j] = dp[i + 1][j] | dp[i + 1][j + array[i]]
    return dp[0][0]

```



**题目5**

```
给定两个数组w和v， 两个数组长度相等， w[i]表示第i件商品的重量， v[i]表示第i件商品的价值。 再给定一个整数bag，要求你挑选商品的重量加起来一定不能超 过bag，返回满足这个条件下,你能获得的最大价值。
```

**递归版本**

```python
def maxValue(weight, value, i, now, bag):
    """
    weight重量数组
    value数组
    i当前位置
    now当前已有的重量
    边界条件bag
    """
    # basecase
    if now > bag:
        return -99999
    length = len(weight)
    if i == length:
        return 0
    return max(maxValue(weight, value, i + 1, now, bag), (value[i] + maxValue(weight, value, i + 1, now + weight[i], bag)))

```

**动态规划**

```python
def maxValue2(weight, value, bag):
    rows = len(weight)
    cols = sum(weight)
    dp = [[0] * cols for i in range(rows + 1)]
    # 当i==rows或者j==cols
    for i in range(rows)[::-1]:
        for j in range(cols)[::-1]:
            dp[i][j] = dp[i + 1][j]
            if j + weight[i] <= bag:
                dp[i][j] = max(dp[i + 1][j], value[i] +
                               dp[i + 1][j + weight[i]])
    return dp[0][0]



# 0-1背包问题
def beibao(weight,value,bag):
	if bag==0:
		return 0
	total_weight = sum(weight)
	row= len(value)
	dp=[[0]*(total_weight+1) for _ in range(row+1)]
	for i in range(row+1):
		dp[i][0]=0
	for i in range(1,row+1):
		for j in range(1,total_weight+1):
			dp[i][j] = dp[i-1][j]
			if j>=weight[i-1]:
				dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i-1]]+value[i-1])
	return  dp[row][bag]
```

**分割等和子集**

```python
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
注意:
每个数组中的元素不会超过 100
数组的大小不会超过 200
示例 1:

输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
 
示例 2:

输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.

```

对于这个问题，看起来和背包没有任何关系，为什么说它是背包问题呢？

首先回忆一下背包问题大致的描述是什么：

给你一个可装载重量为 `W` 的背包和 `N` 个物品，每个物品有重量和价值两个属性。其中第 `i` 个物品的重量为 `wt[i]`，价值为 `val[i]`，现在让你用这个背包装物品，最多能装的价值是多少？

那么对于这个问题，我们可以先对集合求和，得出 `sum`，把问题转化为背包问题：

**给一个可装载重量为** **`sum / 2`** **的背包和** **`N`** **个物品，每个物品的重量为** **`nums[i]`****。现在让你装物品，是否存在一种装法，能够恰好将背包装满**？

你看，这就是背包问题的模型，甚至比我们之前的经典背包问题还要简单一些，**下面我们就直接转换成背包问题**，开始套前文讲过的背包问题框架即可。

# 二、解法分析

**第一步要明确两点，「状态」和「选择」**。

状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。

**第二步要明确** **`dp`** **数组的定义**。

按照背包问题的套路，可以给出如下定义：

`dp[i][j] = x` 表示，对于前 `i` 个物品，当前背包的容量为 `j` 时，若 `x` 为 `true`，则说明可以恰好将背包装满，若 `x` 为 `false`，则说明不能恰好将背包装满。

比如说，如果 `dp[4][9] = true`，其含义为：对于容量为 9 的背包，若只是用前 4 个物品，可以有一种方法把背包恰好装满。

或者说对于本题，含义是对于给定的集合中，若只对前 4 个数字进行选择，存在一个子集的和可以恰好凑出 9。

根据这个定义，我们想求的最终答案就是 `dp[N][sum/2]`，base case 就是 `dp[..][0] = true` 和 `dp[0][..] = false`，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。

**第三步，根据「选择」，思考状态转移的逻辑**。

回想刚才的 `dp` 数组含义，可以根据「选择」对 `dp[i][j]` 得到以下状态转移：

如果不把 `nums[i]` 算入子集，**或者说你不把这第** **`i`** **个物品装入背包**，那么是否能够恰好装满背包，取决于上一个状态 `dp[i-1][j]`，继承之前的结果。

如果把 `nums[i]` 算入子集，**或者说你把这第** **`i`** **个物品装入了背包**，那么是否能够恰好装满背包，取决于状态 `dp[i-1][j-nums[i-1]]`。

首先，由于 `i` 是从 1 开始的，而数组索引是从 0 开始的，所以第 `i` 个物品的重量应该是 `nums[i-1]`，这一点不要搞混。

`dp[i - 1][j-nums[i-1]]` 也很好理解：你如果装了第 `i` 个物品，就要看背包的剩余重量 `j - nums[i-1]` 限制下是否能够被恰好装满。

换句话说，如果 `j - nums[i-1]` 的重量可以被恰好装满，那么只要把第 `i` 个物品装进去，也可恰好装满 `j` 的重量；否则的话，重量 `j` 肯定是装不满的。

```python
class Solution:
		def canPartition1(self, nums: List[int]) -> bool:
        #递归，时间复杂度为2^n。
        def dp(index,res,total_sum):
            #走到底了，说明还没有找到，那么返回False
            if index==len(nums):
                return False
            #找到了，那么就返回True
            if res==total_sum:
                return True
            return dp(index+1,res,total_sum) or dp(index+1,res+nums[index],total_sum)
        total_sum = sum(nums)
        if total_sum%2==1:
            return False
        if len(nums)==1:
            return  False
        return  dp(0,0,total_sum/2)

    def canPartition(self, nums: List[int]) -> bool:
        length = len(nums)
        total_sum = sum(nums)
        if length==1:
            return False
        if total_sum%2==1:
            return False
        res = int(total_sum/2)
        #nums中全为正整数
        dp =[[False]*(res+1) for i in range(length+1)]
        for i in range(length+1):
            dp[i][0]=True
        for i in range(1,length+1):
            for j in range(1,res+1):
                #如果前面i-1个数能构成j，那么前i个数肯定也能构成j
                dp[i][j]=dp[i-1][j]
                if j>=nums[i-1]:
                    dp[i][j] = dp[i-1][j-nums[i-1]] or  dp[i-1][j]
        return dp[length][res]

```



**题目**

```
给定一个整数n,求以1,2,3...n为节点组成的二叉搜索树(BST)有几种
```

```

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

```

**递归思路**

如果n==0 或者n==1，那么返回的以0或者1为根节点构成的二叉搜索树的个数为1，现在我们定义一个函数$f(n)$，n表示以n为输入的能构成的二叉搜索树的个数，那么根的左边有$i-1$个数，根的右边有$n-i$个数，那么左边的二叉树的个数为$f(i-1)$,右边二叉树的个数为$f(n-i)$,那么以n为根节点的树个数为$f(i-1)*f(n-i)$.
$$
f(0)=1 \\
f(1)=1 \\
f(n) =\sum_{i=1}^{n}{f(i-1)*f(n-i)}
$$

```python
def numTrees( n):
	"""
	:type n: int
	:rtype: int
	"""
	if n == 0 or n == 1:
		return 1
	res = 0

	for j in range(1, n + 1):
		res += numTrees(j - 1) * numTrees(n - j)

	return res

def numTrees1(n):
	dp = [0 for i in range(n+1)]
	dp[0]=1
	dp[1] = 1
	for i in range(2,n+1):
		for j in range(1,i+1):
			dp[i] += dp[j-1]*dp[i-j]
	return  dp[-1]

```



考虑根的范围$(1<=i<=n)$,假设当前根为$i$,那么根左边有$i-1$个数，根右边有$n-i$个数，那么左子树个数为$f(i-1)$,右子树个数为$f(n-i)$,那么此时以$i$为根节点的数有$f(n-i)*f(i-1)$



**题目**

```
将一个二维数组排列成金字塔的形状，找到一条从塔顶到塔底的路径，使路径上的所有点的和最小，从上一层到下一层只能挑相邻的两个点中的一个
输入数组如下所示
    [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
```

```python
## 暴力递归
def minweightsum(array,i,j):
	#如果到到达最后最后一行,那么就返回
	# rows = len(array)
	# cols = max([len(i) for i in array])
	if i == len(array)-1:
		return  array[i][j]
	#只能往下走以及往斜下方走
	res = array[i][j]
	return res+ min(minweightsum(array,i+1,j),minweightsum(array,i+1,j+1))


###动态规划
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        if len(triangle) == 0:
            return
        length = len(triangle)
        max_col = len(triangle[-1])
        dp = [[0] * max_col for _ in range(length)]
        for i in range(max_col):
            dp[-1][i] = triangle[-1][i]
        for i in range(length-1)[::-1]:
            for j in range(i+1)[::-1]:
                dp[i][j] = triangle[i][j]+min(dp[i+1][j],dp[i+1][j+1])
        return dp[0][0]
        


```

**连续子数组的最大和**

```python
"""
构建一个一维的dp表,i表示i位置的最大连续子数组和
"""

def maxSubArray( nums: list) -> int:
	if len(nums) == 0 or nums is None:
		return 0
	length = len(nums)
	dp = [0]*length
	dp[0] = nums[0]
	for i in range(1, length):
		if dp[i - 1] >= 0:
			dp[i] = dp[i - 1] + nums[i]
		else:
			dp[i] = nums[i]
	return  max(dp)

```



**路径问题**

```python
"""
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每 

"""
def uniquePaths(m,n):
	#构建一个二维的dp表
	dp = [[0]*n for i in range(m)]
	dp[m-1][n-1]=1
    #最后一行只能往右边走
	for i in range(n):
		dp[m-1][i] = 1
    #最后一列只能往下走
	for j in range(m):
		dp[j][n-1]=1
	for i in range(m-1)[::-1]:
		for j in range(n-1)[::-1]:
			dp[i][j] = dp[i+1][j]+dp[i][j+1]
	return  dp[0][0]

```



**路径问题2**

```python

"""一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？


输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右


"""
def uniquePathsWithObstacles( obstacleGrid) -> int:
        rows = len(obstacleGrid)
        cols = len(obstacleGrid[0])
        dp = [[0] * cols for _ in range(rows)]
        if dp[0][0] == 1 or dp[rows - 1][cols - 1] == 1:
            return 0
        dp[0][0]=1
        #对第一行
        for i in range(cols):
            if obstacleGrid[0][i]!=1:
                dp[0][i]=1
            else:
                dp[0][i]=0
                break
        for j in range(rows):
            if obstacleGrid[j][0]!=1:
                dp[j][0]=1
            else:
                dp[j][0]=0
                break
        for i in range(1,rows):
            for j in range(1,cols):
                if obstacleGrid[i][j]!=1:
                    dp[i][j]=dp[i-1][j]+dp[i][j-1]
                else:
                    dp[i][j]=0
        return dp[rows-1][cols-1]
```

**跳跃游戏**

> 给定一个非负整数数组，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个位置。
>
> 示例 1:
>
> 输入: [2,3,1,1,4]
> 输出: true
> 解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。
> 示例 2:
>
> 输入: [3,2,1,0,4]
> 输出: false
> 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
>
> 

**思路1**

用一个一维dp表来表示每个位置可达的状态，i位置表示i位置是否可达，如果i位置可达，那么之前所有的位置都可达，如果i位置不可达，那么i位置之后的位置肯定是不可达的。判断i位置是否可达，就需要判断之前位置上能否跳到该位置。时间复杂度o(n^2)

```python
class Solution:
	def canJump(self, nums: List[int]) -> bool:
		if len(nums) == 1:
			return True
		dp = [0] * len(nums)
		dp[0] = 1
		for i in range(1, len(nums)):
			#如果前一个位置可达，并且前一个位置能到当前位置，当前位置可达,如果当前位置都不可达，那么后面的位置一定不可达
			for j in range(i-1,-1,-1):
				if nums[j]+j>=i:
					dp[i]=1
					break
			#如果当前位置都不可达直接返回False
			if not dp[i]:
				return False
		return True

```

**思路2**

> 换一个思路，题目是问能否达到最后一个位置，那么我们就从最后一个位置开始判断，如果之前有个点a能跳到最后一个位置，那么问题就变成是否有个位置能跳到a点。因此如果最后的跳跃位置是从0开始的，那么就能跳到该位置，否则不能到该位置。只要遍历一遍数组就可以。时间复杂度o(n)

```Python
class Solution:
	def canJump(self, nums: List[int]) -> bool:
		n = len(nums)
		last_position = n - 1
		for i in range(n - 1, -1, -1):
			if (nums[i] + i) >= last_position:
				last_position = i
		return last_position == 0
```

**跳跃游戏②**

```python
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

```

思路1：带备忘录的递归，

<img src="/Users/eason/Downloads/IMG_0047.jpg" alt="IMG_0047" style="zoom:33%;" />



```python
    def jump(self, nums: List[int]) -> int:
        mem ={}
        def dp(index):
            if index in mem:
                return mem[index]
            if index>=len(nums)-1:
                return 0
            #开始做选择
            res = float('inf')
            #因为range 是从0开始的，我们需要索引往前走一步，因此for循环的时候需要从1开始
            for i in range(1,nums[index]+1):
                sub = dp(index+i)
                #比较当前层所有选择，选最小的那个
                res = min(sub+1,res)
            mem[index]=res
            return  mem[index]
        length = len(nums)
        if length==0:
            return  0
        return dp(0)
```

对于这题，我们有必要求解出当前步能跳的范围的所有解，然后去选择一个最小的步数么？比如对于[2,3,1,1,4],比如当index=0时，我们可以跳的步数为2，我们可以跳到1，也可以跳到2.如果跳到1，那么后续能跳的范围为[2,3,4],如果跳到2，后续能跳的范围为[3],此时我们发现跳到1的选择是比跳到2更优的，因为跳到1之后的解范围是覆盖了跳到2的解范围的。因此我们在后续选择跳落点的时候，就选能跳最远的那个跳落点。

<img src="/Users/eason/Library/Application%20Support/typora-user-images/image-20201222194617062.png" alt="image-20201222194617062" style="zoom:50%;" />

`i、end`表示当前index能跳的范围，farthest表示`[i,end]`这个范围内能跳的最远的跳落点

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        if len(nums)==0:
            return 0
        start=0
        end = 0
        farthest = 0
        jumps=0
        for index in range(len(nums)-1):
            #当前index能跳的范围中跳的最远的位置
            farthest = max(index+nums[index],farthest)
            #当前index是否在上一个index能跳的最远位置了？，此时一定要往后面跳了
            if index==end:
                if index==len(nums)-1:
                    return jumps
                jumps+=1
                end = farthest
        return jumps
```



**凑硬币问题**

> 给定不同面额的硬币 coins 和一个总金额 amount 总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。
>
> 输入: coins = [1, 2, 5], amount = 11
> 输出: 3 
> 解释: 11 = 5 + 5 + 1
> 
> 输入: coins = [2], amount = 3
> 输出: -1

*思路*

首先应该想暴力解如何求，首先如果选择面额为1的硬币，那么总金额为`amount-1`等于10，那么问题就变为金额为总金额10的应该用这些硬币怎么凑。这个问题可以用递归来解，首先画出递归树。

![](../image/硬币.png)

> 递归的终止条件：如果总金额为0了，那么就需要返回了，这里题目要求的是硬币的数量，如果总金额为0，那么任意面额的硬币都无法做到，因此返回0

```python
class Solution:
	def coinChange(self, coins: List[int], amount: int) -> int:
		if amount == 0:
			return 0
		res = float('inf')
		for coin in coins:
			if coin > amount:
				continue
			sub = self.coinChange(coins, amount - coin)
			if sub!=-1:
				res = min(res,sub+1)
		if res!=-1:
			return res
		return -1
```

**改为动态规划**

> 从递归树中，可以看到有很多地方都是重复计算的，所以可以使用剪枝来减少子问题的数量，或者使用自底向上的动态规划来求解。对于原问题需要求解如果使用这些面额来凑成总金额为11最少的硬币数，如果我们知道凑成10元的最少硬币数的话，如果从给定的面额中能凑出11的话那么我们也就知道答案了。因此我们可以从金额为1的开始，求解凑出1需要使用的最少硬币数。


```python
class Solution:
	def coinChange(self, coins: List[int], amount: int) -> int:
		dp = [0]*(amount+1)
		for i in range(1,amount+1):
			cost = float('inf')
			for coin in coins:
				if coin<=i:
					cost = min(cost,dp[i-coin]+1)
			dp[i]=cost

		if dp[amount]==float('inf'):
			return -1
		return dp[amount]
```

****

**零钱兑换2**

```
给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 
示例 1:

输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
示例 2:

输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
示例 3:

输入: amount = 10, coins = [10] 
输出: 1

```

思路一：使用dfs枚举出所有可能的凑钱方案，时间复杂度为$O(2^n),$在进行dfs时，要注意去除重复的可能解。

```python
class Solution:
      def change(self, amount: int, coins: List[int]) -> int:
        ## 通过dfs来枚举出所有不重复的可能解,时间复杂度为叶子节点个数，应该是指数级别的。
        def __dfs(nums,money,start,pre,res):
            ## 递归终止条件
            if sum(pre.copy())==money:
                res.append(pre.copy())
                return
            if sum(pre.copy())>money:
                return
            #遍历当前层的所有节点，然后做选择,注意循环开始的位置
            for i in range(start,len(nums)):
                pre.append(nums[i])
                __dfs(nums,money,i,pre,res)
                pre.pop()
        # if len(coins)==0:
        #     return  0
        # if amount<0:
        #     return 0
        res =[]
        __dfs(coins, amount,0,[], res)
        return len(res)
  
```

思路2：动态规划

如何定义`状态`？。`dp[i][j]`表示coins中前i个硬币能凑成金额为j的次数。

1.初始化

​	`dp[0][1~j]=0`0个硬币除了0以外都不能凑

​	`dp[i][0]`要凑成0元，就一种凑法，不适用任何硬币

注意，我们这个问题的特殊点在于物品的数量是无限的，所以这里和之前写的背包问题文章有所不同。

**如果你不把这第** **`i`** **个物品装入背包**，也就是说你不使用 `coins[i]` 这个面值的硬币，那么凑出面额 `j` 的方法数 `dp[i][j]` 应该等于 `dp[i-1][j]`，继承之前的结果。

**如果你把这第** **`i`** **个物品装入了背包**，也就是说你使用 `coins[i]` 这个面值的硬币，那么 `dp[i][j]` 应该等于 `dp[i][j-coins[i-1]]`。

首先由于 `i` 是从 1 开始的，所以 `coins` 的索引是 `i-1` 时表示第 `i` 个硬币的面值。

`dp[i][j-coins[i-1]]` 也不难理解，如果你决定使用这个面值的硬币，那么就应该关注如何凑出金额 `j - coins[i-1]`。

比如说，你想用面值为 2 的硬币凑出金额 5，那么如果你知道了凑出金额 3 的方法，再加上一枚面额为 2 的硬币，不就可以凑出 5 了嘛。

**综上就是两种选择，而我们想求的** **`dp[i][j]`** **是「共有多少种凑法」，所以** **`dp[i][j]`** **的值应该是以上两种选择的结果之和**：

```python
class Solution:
      def change(self, amount: int, coins: List[int]) -> int:
        if amount<0:
            return 0
        len_w = len(coins)
        dp =[[0]*(amount+1) for i in range(len_w+1)]
        #第一列表示，dp[i][0]coins中前i个硬币能凑成0的次数
        for i in range(len_w+1):
            dp[i][0]=1
        #第一行表示，dp[0][i]表示前0个硬币能能凑成金额为i的次数
        #状态转移方程dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]])
        for i in range(1,len_w+1):
            for j in range(1,amount+1):
                #不用当前的硬币凑
                dp[i][j]=dp[i-1][j]
                if j>=coins[i-1]:
                    #用当前硬币凑+不用当前硬币凑
                    dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]]
        return  dp[len_w][amount]

```

**最长上升子序列**

> 给定一个无序的整数数组，找到其中最长上升子序列的长度。
>
> 输入: [10,9,2,5,3,7,101,18]
> 输出: 4 
> 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

**思路**

首先想暴力解如何解，对于给定的数组，我们可以枚举出所有的子序列，然后找到所有递增的子序列的最大值。枚举的时间复杂度为$O(2^n)$,同时找到所有递增的子序列的时间复杂度为$(n^2)$,因为递归过程中有大量重叠的子问题，以及不满足最优解的序列。我们可以使用动态规划来求解这个问题，设定一个一维的dp数组，每个位置表示以num[i]结尾的最长上升子序列的长度，遍历该之前的所有位置j，如果num[i]>num[j],那么$dp[i]=max(dp[i],dp[j]+1)$

返回max(dp),时间复杂度为$0(n^2)$

```Python
class Solution:
	def lengthOfLIS(self, nums: List[int]) -> int:
		if len(nums) == 0:
			return 0
		if len(nums) == 1:
			return 1
		dp = [0] * len(nums)
		dp[0] = 1
		for i in range(1, len(nums)):
			for j in range(i):
				if nums[i] > nums[j]:
					dp[i] = max(dp[i], dp[j] + 1)
			if dp[i]==0:
				dp[i]=1
		return max(dp)
```

上面的方法的时间复杂度为0(n2),根据题目提示，还有一种$O(nlogn)$的算法。

之前定义的状态是dp[i]表示以第i个数为结尾的最长子序列的长度。现在我们定义dp[i]表示长度为i+1的子序列的最小值，思路是利用贪心+二分搜索的方法。对于相同长度的子序列，我们一直保持其最后一个元素是最小的，这样最后得到的子序列的长度就是最长的子序列的长度。

```python

class Solution:
    def lengthOfLIS(self, hights: List[int]) -> int:
        if len(hights)==0:
            return 0
        tail=[]
        tail.append(hights[0])
        for i in range(1,len(hights)):
            if hights[i]>tail[-1]:
                tail.append(hights[i])
                continue
            else:
                #找到tail中第一个大于hights[i]的数
                left =0
                right = len(tail)
                while left<=right:
                    mid = (left+right)//2
                    if tail[mid]>hights[i]:
                        right = mid-1
                    elif tail[mid]<hights[i]:
                        left = mid+1
                    elif tail[mid]==hights[i]:
                        left=mid
                        break
                tail[left]=hights[i]
        return len(tail)
```

**无重叠区间**

```
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
注意:

可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

```

`定义状态，dp[i]表示以当前第i个区间结尾所能找到的最多的不重叠区间`，然后问题就转化成了类似的求最长上升子序列的长度

如果知道了子问题dp[i-1]的解，那么我们就能知道dp[i]的解，因为我们定义的dp[i]是以当前第i个区间结尾所能找到的最多的不重叠区间.因为没有要求区间一定要连续，所以当前区间可以接在任何它可以接的区间后面。

`状态转移方程:dp[i] = $\max_{0<=j<i}$ {dp[i],dp[j]+1}`

dp[-1]的值后，我们就知道最多的不重叠区间，然后使用总的区间数-dp[-1]就是需要移除的最小数量。

时间复杂度为$O(n^2)$

```python

	def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        #使用动态规划的思路，贪心是动态规划的一种特殊的情况，贪心算法需要满足的条件比动态规划的要多
        # 我们使用dp[i]表示以当前区间结尾时最大的不重叠区间数量
        #时间复杂度为o(n^2) 超时
        if len(intervals)==0:
            return 0
        intervals = sorted(intervals,key=lambda x:x[0])
        dp = [1 for i in range(len(intervals))]
        for i in range(1,len(intervals)):
            for j in range(i):
                if intervals[i][0]>=intervals[j][1]:
                    dp[i] = max(dp[i],dp[j]+1)
        return len(intervals) - max(dp)
      
#贪心，将n^2时间复杂度变为线性的复杂度
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        ## 最小区间移除个数。如果我们知道了最大的不重叠区间的数量，通过总的区间数-最大不重叠区间数=最小区间移除个数
        if len(intervals)==0:
            return 0
        intervals = sorted(intervals,key=lambda x:x[1])
        count=1
        end = intervals[0][1]
        for i in range(1,len(intervals)):
            if intervals[i][0]>=end:
                end = intervals[i][1]
                count+=1
        return  len(intervals)-count
```

**用最少数量的箭来引爆气球**

```
在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球
示例 2：

输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
示例 3：

输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
示例 4：

输入：points = [[1,2]]
输出：1
示例 5：

输入：points = [[2,3],[2,3]]
输出：1

```

思路和无重叠的区间一致，题目告诉我们对于重叠的气球只需要一只箭就可以引爆了，我们不需要知道准确的知道射箭的具体的x位置。因此如果最多有n个气球不重叠，并且每只箭都有效的话，我们至少就需要n只箭就能射爆所有的气球。所以题目就转化为最多有多少个无重叠的区间。也就转化为求最长上升序列的问题。

**注意，对于[3,5],[5,7]**这种区间是重合的，我们算它是重合的。

<img src="/Users/eason/Library/Application%20Support/typora-user-images/image-20201216205442752.png" alt="image-20201216205442752" style="zoom:50%;" />



```python
class Solution:
    def findMinArrowShots(self, intervals: List[List[int]]) -> int:        
        if len(intervals)==0:
            return 0
        intervals = sorted(intervals,key=lambda x:x[1])
        count=1
        end = intervals[0][1]
        for i in range(1,len(intervals)):
            if intervals[i][0]>end:
                end = intervals[i][1]
                count+=1
        return  count

```



**信封嵌套问题**

```
给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

说明:
不允许旋转信封。

示例:

输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。

```

根据题意，只有当一个信封的宽度和高度都比另外一个信封大的时候，另外一个信封才能放入当前的信封中，所以我们首先想到将信封按照w从小到大排序。此时信封以及按照w进行升序排序了，如果i+1个信封的w和h大于第i个信封的w,h那么信封就能嵌套。同时题目要求我们求最多的信封的个数，其实可以将问题转换为最长的上升子序列。因此我们将状态定义为dp[i]表示以第i个信封作为最后一个信封能套的最多信封数。

但是我们按照w排序的时候需要注意到当w相同时的信封，比如[[5,3],[5,4],[6,5]]，我们知道最多的信封个数为[[5,3],[6,5]]。为了保证w相同的信封最多被计算一次。对于w相同的信封，我们需要按h降序排序。此时我们取出h作为一个序列，然后求这个序列的最长上升子序列，其解就是信封问题的解。

```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        from  functools import  cmp_to_key
        def userSort(right,left):
            #首先按照w升序排序，对于相同的w，高度降序排序。
            if right[0]==left[0]:
                return left[1]-right[1]
            else:
                return right[0]-left[0]
        if len(envelopes)==0:
            return 0
        envelopes = sorted(envelopes,key=cmp_to_key(userSort))
        hights=[w[1] for w in envelopes ]
        tail=[]
        tail.append(hights[0])
        for i in range(1,len(envelopes)):
            if hights[i]>tail[-1]:
                tail.append(hights[i])
                continue
            else:
                #找到tail中第一个大于hights[i]的数
                left =0
                right = len(tail)
                while left<=right:
                    mid = (left+right)//2
                    if tail[mid]>hights[i]:
                        right = mid-1
                    elif tail[mid]<hights[i]:
                        left = mid+1
                    elif tail[mid]==hights[i]:
                        left =mid
                        break
                tail[left]=hights[i]
        return len(tail)
```

**最长公共子序列**

```
给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0

输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。


输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
```

两个字符串的动态规划问题一般都是使用两种套路去解决。第一种是定义二维dp表`dp[i][j]`表示的是text1[0:i]和text2[0:j]的最长公共子序列的长度。另一种是定义一个一维的dp表`dp[i]`，表示的以第i个字符结尾的某个状态。

在最长公共子序列的问题中，我们定义`dp[i][j]`表示text1中前i个字符和text2中前j个字符的最长公共子序列。

首先初始化:

1. `dp[0][j] `=0,text1第0个字符表示空格，和text2中前j个字符最长公共子序列都为0

2. `dp[i][0]`=0 , text1中前i个字符和text2中第0个字符的最长公共子序列都为0
3. `dp[i][j]=dp[i-1][j-1]+1, if text1[i]==text2[j],`
4. `dp[i][j]=max(dp[i-1][j],dp[i][j-1])`

最后我们要求的是`dp[len(text1)-1][len(text2)-1]`位置的值。

<img src="/Users/eason/Library/Application%20Support/typora-user-images/image-20201210144614931.png" alt="image-20201210144614931" style="zoom:50%;" />

状态转移过程

<img src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4nvYibZRJ0DuVaq9sYlNtJIhck5XmxdMxxhaOXapuShhkblDrZdr1HxSjPjIJz6aduSVRUKxgWua6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        if len(text1)==0 or len(text2)==0:
            return 0 
        dp = [[0]*(len(text2)+1) for i in range(len(text1)+1)]
        for i in range(1,len(text1)+1):
            for j in range(1,len(text2)+1):
                if text1[i-1]==text2[j-1]:
                    dp[i][j]=dp[i-1][j-1]+1
                else:
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])
        return dp[len(text1)][len(text2)]
```

**两个字符串的删除操作**

```python
给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

示例：

输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"

```

思路和编辑距离是一样的，只不过里的操作是只能删除。对于两个字符串问题。使用动态规划去解的思路使用一个二维数组。

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1 = len(word1)
        len2 = len(word2)
        if len1==0:
            return len2
        if len2==0:
            return len1
        dp =[[0]*(len2+1) for i in range(len1+1)]
        for i in range(1,len1+1):
            dp[i][0]=i
        for j in range(1,len2+1):
            dp[0][j]=j

        for i in range(1,len1+1):
            for j in range(1,len2+1):
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i-1][j],dp[i][j-1])+1
        return dp[len1][len2]
      
      
        def minDistance(self, word1: str, word2: str) -> int:
        mem={}
        def dp(i,j):
            if (i,j) in mem:
                return mem[(i,j)]
            if i==-1:
                return  j+1
            if j==-1:
                return i + 1
            if word1[i]==word2[j]:
                mem[(i,j)]=dp(i-1,j-1)
            else:
                mem[(i,j)]= min(dp(i-1,j),dp(i,j-1))+1
            return mem[(i,j)]
        length1=len(word1)
        length2=len(word2)

        return dp(length1-1,length2-1)
```

**两个字符串的最小ascii删除和**

```
给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。

输入: s1 = "sea", s2 = "eat"
输出: 231
解释: 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。
在 "eat" 中删除 "t" 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。

```

思路和两个字符串的删除是一致的。只不过字符串删除最小步数中无论删除s1中的字符还是删除s2中的字符，需要的步数都是一样的。但是在这题中，如果有好几种删除的方法能使得两个字符串相同，我们需要取删除ASCII字符最小的那个策略。	

```python
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        mem={}
        def dp(i,j):
            if (i,j) in mem:
                return mem[(i,j)]
            if i==-1:
                left_sum_ascii = sum(map(lambda  x:ord(x),str(s2[:j+1])))
                return left_sum_ascii
            if j==-1:
                right_sum_ascii= sum(map(lambda  x:ord(x),str(s1[:i+1])))
                return right_sum_ascii
            if s1[i]==s2[j]:
                mem[(i,j)]= dp(i-1,j-1)
            else:
                mem[(i,j)]= min(dp(i-1,j)+ord(s1[i]),dp(i,j-1)+ord(s2[j]))
            return mem[(i,j)]
        len1=len(s1)
        len2=len(s2)
        return dp(len1-1,len2-1)
```

**旅行商问题**

> TSP问题(旅行商问题)是指旅行家要旅行n个城市，要求各个城市经历且仅经历一次然后回到出发城市，并要求所走的路程最短。假设现在有四个城市，0,1,2,3,4。他们之间的代价如图一，可以存成二维表的形式

​                                  ![](../image/tsp1.png)![](../image/tsp1.gif)

> 思路：设s，s1,s2,s3...sp,s是从s出发然后回到s的一条路径长度最短的简单回路，假设从s到下一个城市s1的路径以及求出来了，然后问题就变为求子问题从s1出发回到s的最短路径了。
>
> 假设从顶点s出发，令$d(i,V')$表示从顶点i出来经过$V'$中各个顶点一次，最后回到出发点s的最短路径。
>
> - 当V‘为空集的时候,$d(i,V')$表示从i不经过任何点回到出发点的最短路径，此时$d(i,V')$就是城市i到出发点s之间的距离了。
>
> - 如果V'不空，那么就是对子问题的最优求解，必须在V'这个城市集合中每次尝试一个，并求出最优解。
>
>   $d(i,V') = min(c_{ik}+d(k,V'-{k}))$

**递归树**

![](../image/tsp2.gif)



     我们要求的最终结果是d(0,{1,2,3}),它表示，从城市0开始，经过{1,2,3}之中的城市并且只有一次，求出最短路径.
    ②d(0,{1,2,3})是不能一下子求出来的，那么他的值是怎么得出的呢？看上图的第二层，第二层表明了d(0,{1,2,3})所需依赖的值。那么得出：
    
       d(0,{1,2,3})=min  {
    
                                    C01+d(1,{2,3})
    
                                    C02+d{2,{1,3}}
    
                                    C03+d{3,{1,2}}
    
                                  }
    
     ③d(1,{2,3})，d(2,{1,3})，d(3,{1,2})同样也不是一步就能求出来的，它们的解一样需要有依赖，就比如说d(1,{2,3})
    
       d(1,{2,3})=min{
    
                              C12+d(2,{3})                             
    
                              C13+d(3,{2})
    
                              }
    
       d(2,{1,3})，d(3,{1,2})同样需要这么求。
    
    ④按照上面的思路，只有最后一层的，当当V’为空集时，Cis的值才可以求，它的值是直接从路径的邻接表求出来的。

**dp填表**

![](../image/tsp2.png)







**编辑距离**

![](../image/编辑距离.png)

> 思路：对于两个字符串的动态规划，可以使用双指针的思路。指针$i$,$j$分别指向字符串的尾部。如何当前字符不相同，那么有三种操作可以进行。1.替换$i$指针处的字符，2.删除$i$指针处的字符，3.在i指针后插入j指针指向的字符。
>
> 对于这三种操作，$i$,$j$指针都有着不同的操作。使用dp(i,j)这个递归函数来表示将word1变为Word2需要的最少的操作步数。
>
> 	1. 替换$i$指针处的字符，dp(i-1,j-1)+1,此时，$i,j$指向相同的字符，$i,j$同时向前移动
>  	2. $i$字符后插入$j$字符的字符，j向前移动
>  	3. 删除i字符处的字符，i向前移动。
>
> 使用二维dp表来处理重叠子问题。`dp[i][j]`表示word1前i个字符和word2前j个字母之间的编辑距离.

![](https://pic.leetcode-cn.com/7b43e3972bae8a47ce9a8dcb5f9f504ade318dda175736006fef47f2314ca839-file_1567564774425)



```python
class Solution:
    #递归
	def minDistance(self, word1: str, word2: str) -> int:
		# 对于两个字符串的动态规划，可以考虑
		def dp(i, j):
			#如果第一个字符串走到底了，那么返回字符串2剩下的还没有处理的长度
			if i == -1:
				return j + 1
			if j == -1:
				return i + 1

			if word1[i]==word2[j]:
				return dp(i-1,j-1)
			else:
				return min(dp(i-1,j)+1,dp(i,j-1)+1,dp(i-1,j-1)+1)

		return  dp(len(word1)-1,len(word2)-1)

    
 ##动态规划
 class Solution:
	def minDistance(self, word1: str, word2: str) -> int:
		if len(word1)==0:
			return len(word2)
		if len(word2)==0:
			return len(word1)

		length1 = len(word1)+1
		length2 = len(word2)+1
		dp = [[0]*(length2) for _ in range(length1)]
		for i in range(length1):
			dp[i][0] =i
		for j in range(length2):
			dp[j][0] = j

		for i in range(1,length1):
			for j in range(1,length2):
				if word1[i-1]==word2[j-1]:
					dp[i][j] = dp[i-1][j-1]
				else:
					dp[i][j] = min(dp[i-1][j]+1,dp[i-1][j-1]+1,dp[i][j-1]+1)
		return dp[len(word1)][len(word2)]  
    
```



**交错字符串**

> 给定三个字符串s1,s2,s3，验证s3是否是由s1和s2交错组成的。
>
> ```
> 输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
> 输出: true
> 
> 输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
> 输出: false
> ```

![](https://pic.leetcode-cn.com/1ea87cbbf785bc31fbc4f10349545947a3bd7dd5c182ca7d038b054b2577e8e2-image.png)

> 思路： 使用`dp[i][j]`来表示s1的前$i$个字符以及s2的前$j$个字符能否构成s3的前$i+j$个字符。首先填第一行和第一列。
>
> 1. `dp[i][0]= s1[i-1]==s3[i-1] 并且dp[i-1][0]=True ` 如果s1的第i个字符和s3的第i个字符相等，并且s3的前i-1个字符能由s1的前i-1个字符构成.
> 2. `dp[0][j]= s2[j-1]==s3[j-1] 并且dp[0][j-1]=True ` 如果s2的第j个字符和s3的第j个字符相等，并且s3的前j-1个字符能由s2的前j-1个字符构成.
> 3. `dp[i][j]=True if  （dp[i-1][j] and s1[i-1]==s3[i+j-1]） 或者（dp[i][j-1] and s2[j-1]==s3[i+j-1]） ` 如果s2的第j个字符和s3的第j个字符相等，并且s3的前j-1个字符能由s2的前j-1个字符构成.
> 4. 最后我们要得的状态是`dp[len(s1)][len(s2)]`

```python
class Solution:
	def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
		length1 = len(s1)
		length2 = len(s2)
		length3 = len(s3)
		if length1 + length2 != length3:
			return False
		# dp[i][j]表示s1的前i个字符和s2的前j个字符能否构成s3的前i+j个字符
		dp = [[False] * (length2 + 1) for _ in range(length1 + 1)]
		dp[0][0] = True
		for i in range(1,length1+1):
			if s1[i-1]==s3[i-1] and dp[i-1][0]:
				dp[i][0] = True
		for j in range(1,length2+1):
			if s2[j-1]==s3[j-1] and dp[0][j-1]:
				dp[0][j]=True
		for i in range(1,length1+1):
			for j in range(1,length2+1):
				dp[i][j] = (dp[i-1][j] and (s1[i-1]==s3[i+j-1])) or (dp[i][j-1] and (s2[j-1]==s3[i+j-1]))

		return dp[length1][length2]
```

**不同的子序列**

```python
给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。

一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

示例 1:

输入: S = "rabbbit", T = "rabbit"
输出: 3
解释:

如下图所示, 有 3 种可以从 S 中得到 "rabbit" 的方案。
(上箭头符号 ^ 表示选取的字母)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
```

> 暴力思路，枚举出s的所有子序列，然后统计在子序列中T出现的次数。

```python
class Solution:
	def numDistinct(self, s: str, t: str) -> int:
		res =[]
		self.series(s, 0, '', res)
		return  res.count(t)

	def series(self, s, index, cur, res):
		if index == len(s):
			res.append(cur)
			return
		return self.series(s, index + 1, cur, res) or self.series(s, index + 1, cur + s[index],res)
```

> 思路2：动态规划，因为是要求T在s的子序列中出现的次数，而s的子序列就是s的子集，所以我们要求的也就是T等同于s的那些子集，而s的子集的求法是s的每一个位置选择或者不选择。那我们就希望知道选择了s的那些位置可以组成T，因此我们可以将任务进行分解，如果我们知道了T的前i-1个字符可以由S的那些位置匹配的次数，我们就可以知道前i个字符由s的那些位置构成。
>
> ![](https://pic.leetcode-cn.com/7cbaac1d6171973f6e175d5ca6923029b8ebf0748f5c11526e74ff3da22b869c-Snipaste_2019-07-31_14-26-10.jpg)
>
> 使用`dp[i][j]`表示T中前i个字符可以由s前j个字符匹配上的次数。
>
> - if `T[i]=s[j]`，`dp[i][j]=dp[i-1][j-1]+dp[i][j-1]`
> - if `T[i]!=s[j]`,`dp[i][j]=dp[i][j-1]`

```python
class Solution:
	def numDistinct(self, s: str, t: str) -> int:
		length1 = len(s)
		length2 = len(t)
		dp=[[0]*(length1+1) for _ in range(length2+1)]
		dp[0][0]=1
		for i in range(1,length1+1):
			dp[0][i]=1
		for i in range(1,length2+1):
			for j in range(1,length1+1):
				if t[i-1]==s[j-1]:
					dp[i][j]=dp[i][j-1]+dp[i-1][j-1]
				else:
					dp[i][j]=dp[i][j-1]

		return dp[length2][length1]

if __name__=='__main__':
	s= Solution()
	print(s.numDistinct('rabbbit','rabbit'))
```

**最长的有效括号**

> 给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。
>
> 示例 1:
>
> 输入: "(()"
> 输出: 2
> 解释: 最长有效括号子串为 "()"
> 示例 2:
>
> 输入: ")()())"
> 输出: 4
> 解释: 最长有效括号子串为 "()()"

> 思路:
>
> 使用一维dp,每个位置表示以当前字符结尾的最长的有效括号长度。
>
> 分类讨论：
>
> 1. 如果当前字符为')':
>    1. 如果s[i-1]=='(':那么dp[i] = dp[i-2]+2
>    2. 否则如果s[i-1]==')' 并且 i-dp[i-1]-1>=0 并且s[i-dp[i-1]-1]=='(',那么dp[i] = dp[i-1]+2+dp[i-dp[i-1]-28

```python
class Solution:
	def longestValidParentheses(self, s: str) -> int:
		if len(s)==1 or s is None:
			return 0
		length = len(s)
		dp =[0]*length
		helper =[]
		valid_str = {'(':')'}
		for i in range(length):
			if i>0 and s[i]==')':
				if s[i-1]=='(':
					dp[i] = dp[i-2]+2
				elif s[i-1]==')' and i-dp[i-1]-1>=0 and s[i-dp[i-1]-1]=='(':
					dp[i] = dp[i-1]+2 +dp[i-dp[i-1]-2]
		return max(dp)

```

**股票问题**

给定一个表示每天股票价格的数组，什么因素决定了可以获得的最大收益？可能因素有在哪些天进行交易以及允许交易的次数。

下面通过状态机来统一处理该类问题，首先介绍一些基本符号:

`n`表示股票数组的长度

`i`表示第i天

`K`表示允许交易的最大次数

`T[i][k]`表示在第i天结束是，最多进行k次交易可以获得的最大的收益

对于`T[i][k]`这个数组，我们可以知道一些basecase的值是如何的。比如`T[0][0]=0,T[0][1]=-n[0],T[-1][0]=0`，现在我们将`T[i][k]`关联到子问题上去，`T[i-1][k],T[i][k-1],T[i-1][k-1]`,如果子问题求解了，那么我们的最终解也就知道了，那么状态转移方程怎么来呢？也就是我们的最终解是怎么从子问题转移过来的呢？

对于股票问题`T[i][k]`表示的是第i天最多进行k次交易得到的最大的收益，那么我们知道对于交易来说只有三种可能的情况：`买入，卖出，不操作`,那么我们怎么知道哪种操作能带来最大的收益呢？答案就是一一尝试一遍，在没有限制的条件下我们在每天都尝试这三种操作，然后选择收益最大的哪种操作作为最终的操作。然后题目中对我们的操作是有限制的，买入股票后必须卖出股票才能重新买入股票，同时买入卖出算是一次交易。因此如果你决定了在第i天买入股票，那么在买入之前你必须持有0份股票。同理，如果你决定在i天卖出股票，那么在卖出之前你必须持有1份股票。

因此对于`T[i][k]`的定义需要分成两种状态：

- `T[i][k][0]`表示在第i天结束时，最多进行k次交易且交易结束之后持有0份股票获得的最大的收益。

- `T[i][k][1]`表示在第i天结束时，最多进行k次交易且交易结束之后持有1份股票获得的最大的收益。

使用新的状态表示之后，可以得到基准情况和状态转移方程。

基准情况:

`T[-1][k][0]=0,T[-1][k][1]=-inf`

`T[i][0][0]=0,T[i][0][1]=-inf`

状态转移方程:

`T[i][k][0]=max(T[i-1][k][0],T[i-1][k][1]+price[i])`

`T[i][k][1]=max(T[i-1][k][1],T[i-1][k-1][0]-price[i])`

对于`T[i][k][0]`,当天结束时持有的股票份额为0，所以当天的操作只能是休息或者卖出。`T[i-1][k][0]`表示的是当天休息的最大收益，因为当天没有操作，所以最大收益由第i-1天的状态决定，`T[i-1][k][1]+price[i]`表示的是当天卖出股票的最大收益。注意到允许的最大交易次数是不变的，因为每次交易包含两次成对的操作，买入和卖出。只有买入操作会改变允许的最大交易次数。

对于状态转移方程中的 `T[i][k][1]`，第 i 天进行的操作只能是休息或买入，因为在第 i 天结束时持有的股票数量是 1。`T[i - 1][k][1]` 是休息操作可以得到的最大收益，`T[i - 1][k - 1][0] - prices[i] `是买入操作可以得到的最大收益。注意到允许的最大交易次数减少了一次，因为每次买入操作会使用一次交易.

为了得到最后一天结束时的最大收益，可以遍历股票股票的价格，根据状态转移方程来计算`T[i][k][1]和T[i][k][1]`的值，最终答案是`T[N-1][k][0]`,因为结束时未持有股票的收益一定大于持有股票时的收益。因为对于最后一天持有一份股票的只有两种情况：第一种情况是在最后一天买入，第二种情况是前一天买入。对于第一种情况如果选择不买入收益肯定比买入高，因为你买入还需要钱。对于第二种情况你最后一天卖出收益肯定比你不操作的收益来高。因此最后一天持有0份股票的收益一定高于持有1份的股票。

现在我们就使用上诉状态转移方程来解决一下特定情况下的解：

上述六个股票问题是根据 `k` 的值进行分类的，其中 `k` 是允许的最大交易次数。最后两个问题有附加限制，包括「冷冻期」和「手续费」。通解可以应用于每个股票问题

**情况一：k = 1**
情况一对应的题目是「121. 买卖股票的最佳时机」。

对于情况一，每天有两个未知变量：`T[i][1][0] 和 T[i][1][1]`，状态转移方程如下：

`T[i][1][0]=max(T[i-1][1][0],T[i-1][1][1]+price[i])`

`T[i][1][1]=max(T[i-1][1][1],T[i-1][1][0]-price[i])`

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        #使用状态机来处理股票买卖的问题
        #在股票买卖的问题中，状态有天数、买卖的次数，当前股票的持有状态，通过枚举我们可以
        #枚举出所有的状态，当前的状态的效果是我们做出最佳的选择的出来的
        #dp[i][k][0]表示第i天第k次交易未持有股票的收益，dp[i][k][1]表示第i天第k次交易持有股票的收益
        #dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1]+price[i])
        #dp[i][k][1] = max(dp[i-1][k][1],dp[i-1][k-1][0]-price[i])
        # bad base
        """
        dp[i][0][0]=dp[0][k][0]==0,不管当前是第几次交易，只要是第1天未持有股票，那么我的收益就是为0
        dp[i][0][1]=-inf 还没交易就持有股票是不可能的事情，使用-inf来表示这种，dp[0][k][1]=-price[i]
        """
        dp = [[[0]*2 for i in range(2)] for i in range(len(prices))]
        day = len(prices)
        if day==0:
            return 0
        for j in range(2):
            dp[0][j][0]=0
            dp[0][j][1]=-prices[0]
        for i in range(1,day):
            dp[i][1][0]=max(dp[i-1][1][0],dp[i-1][1][1]+prices[i])
            dp[i][1][1] =max(dp[i-1][1][1],-prices[i])
        return dp[day-1][1][0]
```

**情况2 K=+inf**

情况2对于交易的次数没有限制，也就是说不管你是第k-1次交易还是第k次交易，我们最终要求解的是第i天未持有股票时候的最大收益，此时我们的收益和状况K交易次数没有关系，所以我们可以将它从状态方程中移走。

```python
def maxProfit2(self,prices:List[int])->int:
  #对k不做限制，相对于k-1 等同于k
  days = len(prices)
  if days==0:
    return 0
  dp =[[0]*2 for i in range(days)]
  for i in range(days):
    if i==0:
      dp[i][0]=0
      dp[i][1]=-prices[i]
      continue
      dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])
      dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i])
      return  dp[days-1][0]
```

**情况3 K=2**

情况3 对k的交易次数进行了限制，限制只能交易2次。因为我们需要穷举出所有可能发生的情况，也就是第i天第k次交易持有或未持有的收益状况，情况1因为k=1所以我们不需要关心k，情况2因为对k不做限制，所以也不用考虑。但是情况3明确规定了只能2次，所以在穷举的时候我们也就要遍历所有可能的K。

```python
def maxProfit3(self, prices: List[int]) -> int:
  ##最多只能完成两笔交易
  # T[-1][k][0] = 0, T[-1][k][1] = -Infinity
  # T[i][0][0] = 0, T[i][0][1] = -Infinity
  days = len(prices)
  if days==0:
    return 0
  dp = [[[0]*2 for i in range(3)] for j in range(days)]
  # bad case
  dp[0][1][0] = 0
  dp[0][1][1] = -prices[0]
  dp[0][2][0] = 0
  dp[0][2][1] = -prices[0]
  for i in range(1,days):
    for k in range(1,3):
      dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1]+prices[i])
      dp[i][k][1] = max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i])
  return dp[days-1][2][0]
```

**情况4  最多可以完成K笔交易**

从情况4中我们可以发现，情况123都是情况4的特例。对于情况4，我们也是一样需要遍历k种可能的交易状态。但是题目提示我们，k的取值范围

- `0 <= k <= 10^9`
- `0 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`

从中我们可以发现k的取值可能远远超过股票数组的长度。一旦k的值超过一定范围了，那么我们最后的股票的收益最终就只受到股票数组的长度影响了，此时我们可以发现问题就退化成了情况2。那么k需要达到多少才能造成最后的收益只受股票数组长度影响呢？题目告诉我们每一笔交易都需要买入和卖出，而且当天只能买入或者卖出，那么完成一笔交易至少需要2天的时间，假设我们每天都在买入或者卖出，那么最多只能完成k/2次交易。所以一旦k的大小超过了k/2。那么情况4就退化到情况2了。

```python
    def maxProfit4(self, k: int, prices: List[int]) -> int:
        """
        当k超过一个临界值时，能够进行股票交易的次数就已近不再取决于k的值了，而是取决于能够进行股票交易的数组的长度
        那么这个临界值是多少呢？
        我们知道一笔有收益的交易(买入价格低于卖出价格)至少需要两天时间，也就是说当k> n/2 时，此时问题就退化为K无限制的问题了。
        """
        def maxprofit(prices):
            if len(prices)==0:
                return 0
            days = len(prices)
            dp =[[0]*2 for i in range(days)]
            dp[0][0]=0
            dp[0][1]=-prices[0]
            for i in range(1,days):
                dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])
                dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i])
            return dp[days-1][0]
        
        days = len(prices)
        if days==0:
            return 0
        if k> days/2:
            return maxprofit(prices)
        # dp[days][k+1][2]
        dp = [[[0]*2 for i in range(k+1)] for j in range(days)]
        for j in range(1,k+1):
            dp[0][j][0] = 0
            dp[0][j][1]=-prices[0]
        for i in range(1,days):
            #穷举第i天的所有可能的交易次数
            for j in range(1,k+1):
                dp[i][j][0]=max(dp[i-1][j][0],dp[i-1][j][1]+prices[i])
                dp[i][j][1] = max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i])
        return  dp[days-1][k][0]
```

**情况5 k = +infinity with cooldown**

情况5多了一个限制，也就是我每次卖出以后不能立马买入，需要一个一天的冷冻期。前面几种情况我们的状态转移方程都是

`T[i][k][0]=max(T[i-1][k][0],T[i-1][k][1]+price[i])`

`T[i][k][1]=max(T[i-1][k][1],T[i-1][k][0]-price[i])`

第i天的状态是由第i-1天转移过来的。因为卖出后需要今天一个冷冻期，所以对于当天持有的股票的状态，如果当天的操作是买入的，那么我们需要看它第i-2天未持有时候的收益。此时状态转移方程

`T[i][k][0]=max(T[i-1][k][0],T[i-1][k][1]+price[i])`

`T[i][k][1]=max(T[i-1][k][1],T[i-2][k][0]-price[i])`

```python
    def maxProfit5(self, prices: List[int]) -> int:
        """
        卖出股票后有一个冷冻期，也就是无法在进行交易，也就是说第i天状态为持有的时候，如果考虑其状态从未持有的状态转移过来的时候需要
        考虑其前i-2天的未持有的状态的收益
        """
        days = len(prices)
        if days==0:
            return 0
        dp =[[0]*2 for i in range(days)]
        dp[0][0]=0
        dp[0][1] = -prices[0]
        for i in range(1,days):
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])
            dp[i][1] = max(dp[i-1][1],dp[i-2][0]-prices[i])
        return dp[days-1][0]
```

**情况6 k = +infinity with fee**

情况6规定，每一笔交易都需要支付手续费，同时不对你的交易次数进行限制。因为需要支付手续费，所以我们需要在收益中减去支付手续费的费用。手续费可以在买入或者卖出的时候支付。这里我们统一规定在买入的同时支付手续费

此时状态转移方程如下:

`T[i][k][0]=max(T[i-1][k][0],T[i-1][k][1]+price[i])`

`T[i][k][1]=max(T[i-1][k][1],T[i-2][k][0]-price[i]-fee)`

```python
    def maxProfit6(self, prices: List[int],fee:int) -> int:
        days = len(prices)
        if days==0:
            return 0
        dp=[[0]*2 for i in range(days)]
        dp[0][0]=0
        dp[0][1]=-prices[0]-fee
        for i in range(1,days):
            dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])
            dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i]-fee)
        return dp[days-1][0]
```

### 楼层抛鸡蛋问题

```
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

输入：K = 1, N = 2
输出 2
解释：因为你只有一个鸡蛋，同时你又要确定F，所以你只能从第一层开始往上一次次的实验，那么在最坏的情况下你也需要尝试N次。

```

下面来分析一下这个问题。首先如何如何理解这里的最小？我的理解是你可以使用不同的策略去扔鸡蛋，不同的策略会得到不同的结果。但是只有当使用最优策略去求解的时候，求最小才有意义。所以我这里的理解是`使用最佳的策略(算法)去求得确定F的值的最小移动次数`

下面来分类讨论一下：

1. 当k=1时，此时我们只有一颗鸡蛋。因为我们只能通过这一颗鸡蛋去找到最小的移动次数，所以我们只能从第一层开始一层一层的往上去找。此时最好的情况是在第一层就找到了，最坏的情况是要到最坏一层。因此时间复杂度为$O(N)$

2. 当k=2时，此时我们有两颗鸡蛋。第二颗鸡蛋的使用策略是由第一颗鸡蛋使用的策略决定的。一旦第一课鸡蛋碎了，假设在第k层碎了，那么我们只能从k层以下一层层的重新去找。所以第一颗鸡蛋使用的策略很重要。比如我们在扔第一颗鸡蛋的时候每隔10层扔一次。那么在这种情况下最坏的结果就是我在100层的时候碎了，然后我需要从91层开始最多扔9次来确定这个值。因此最小次数就是19。
3. 当k=inf,此时鸡蛋的个数不再是限制条件了，我们可以使用二分搜索的方法去搜找，复杂度为$O(logN)$
4. 当k=变量n时。此时我们通过动态规划的方法去求解。

首先定义状态，有题目知道我们这里有两个状态，一个是楼层的高度n，另外一个是鸡蛋的个数K。假设函数$T(n,k)$表示的是给定楼层和鸡蛋个数，确定F的值的最小移动次数的函数。我们的思路就是通过递归的思路去一步一步的求解。我们使用`dp[i][j]`来表示共有i层楼梯时j个鸡蛋所需实验的最小次数。这里的i指的是楼层的区间大小而不是第i层，比如[8,9,10]三层，那么这里的i就是3.

同时我们根据在某一层楼抛鸡蛋，鸡蛋碎与不碎将问题分解为两个子问题。

设指定的楼层为 k，k >= 1 且 k <= i：(i表示楼层的高度)

如果鸡蛋破碎，测试 F 值的实验就得在 k 层以下做（不包括 k 层），这里已经使用了一个鸡蛋，因此测出 F 值的最少实验次数是：`dp[k-1][j-1]`
如果鸡蛋完好，测试 F 值的实验就得在 k 层以上做（不包括 k 层），这里这个鸡蛋还能使用，因此测出 F 值的最少实验次数是：`dp[n-k][j]`，例如总共 8 层，在第 5 层扔下去没有破碎，则需要在 [6, 7, 8] 层继续做实验，因此区间的大小就是 8 - 5 = 3。

那么在最坏情况下的解对应于两个子问题中较大的那一个。同时对于不同的k>=1 且k<=i,都会对应一个解，现在我们需要的是最小次数，因此需要取其中最小的一个解。因此得到状态转移方程:
$$
dp[i][j]=\min_{1<=k<=i}(max(dp[i-k][j],dp[k-1][j-1])+1)
$$
最后记得需要+1,因为我们已经在第k层扔了一次了。

初始化值。这里的边界条件还是比较容易列出来的。

- 当n=0时，不管有几个鸡蛋，结果都是0
- 当k=0时,不管共有几层楼，结构都是0
- 当n=1时，`dp[1][j]=1`
- 当k=1时，`dp[i][1]=i`
- 因为楼层最高的高度为n，所以移动次数最大也不会超过楼层的高度，同时我们现在需要求的是最小的次数，因此我们可以将其它位置初始化为楼层的高度n。

综上，代码如下：

```python
class SolutioN:
    def eggPloblem(self,N,K):
        """
        一个楼层一共有N层高，你有K个鸡蛋
        现在有一个楼层F： 0<=F<=N
        在F层以下扔鸡蛋，鸡蛋都不会破碎，在F层以上鸡蛋一定会破碎。现在问你在最坏情况下找到这个F所需要扔鸡蛋的最小次数。
        """
        #构建dp表
        dp =[[N]*(K+1) for i in range(N+1)]
        #第一行表示第0层
        for i in range(K+1):
            dp[0][i]=0
        #第一列表示0个鸡蛋，那么不管是在第几层扔，因为没有鸡蛋，所有结果都是0
        for j in range(N+1):
            dp[j][0]=0
        #第2列，表示一个鸡蛋,那么结果由所在楼层决定
        for j in range(1,N+1):
            dp[j][1]=j
        #第2行,表示第一层
        for i in range(1,K+1):
            dp[1][i]=1
        #枚举从第i层扔鸡蛋的情况
        for i in range(2,N+1):
            for j in range(2,K+1):
                #根据从第t层扔，将问题分为鸡蛋碎和鸡蛋不碎两种情况考虑
                for t in range(1,i+1):
                    dp[i][j]=min(dp[i][j],max(dp[i-t][j],dp[t-1][j-1])+1)
        return dp[N][K]
```

对于上述解法，其时间复杂度为$0(kN^2)f $经过尝试，该复杂度无法通过测试。经过发现`dp[i-t][j],dp[t-1][j-1]`都是单调的函数。
$$
dp[i][j]=\min_{1<=k<=i}(max(dp[i-k][j],dp[k-1][j-1])+1)
$$
对于上述状态转移方程，当固定住i,j时，随着k的增大，`dp[i-k][j]`是个单调不增的函数，`dp[k-1][j-1]`是个单调不减的函数。通过状态转移方程，我们需要求得他们一组较大值之间的最小值，其实就是求dp[i-k][j]==dp[k-1][j-1]对应的k。这样我们就可以使用二分搜索将之前的枚举每一层楼扔鸡蛋的情况通过二分搜索来优化。

```python
class Solution:
    def eggPloblem(self,N,K):
        dp = [[N]*(K+1) for i in range(N+1)]
        for i in range(N+1):
            dp[i][0]=0
        for i in range(K+1):
            dp[0][i]=0
        for i in range(1,N+1):
            dp[i][1]=i
        for i in range(1,K+1):
            dp[1][i]=1
        #开始填表
        for i in range(2,N+1):
            for j in range(2,K+1):
                left = 1
                right = i-1
                while  left<=right:
                    mid = (left+right)//2
                    broken =  dp[mid-1][j-1]
                    notbroken = dp[i-mid][j]
                    if broken>notbroken:
                        right=mid-1
                    elif broken<notbroken:
                        left=mid+1
                    else:
                        break
                dp[i][j]=min(dp[i][j],max(dp[i-mid][j],dp[mid-1][j-1])+1)
        return dp[N][K]
```

算法的时间复杂度为$0(kNlogN)$

**正则表达式匹配**







