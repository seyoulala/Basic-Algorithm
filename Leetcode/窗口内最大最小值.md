### 单调栈结构

```
窗口内的最大值和最小值更新结构
使用双端队列结构(双向链表)

```

![](../image/窗口1.png)



**窗口加数的更新逻辑**，那么准备一个双端队列，还有两个指针L和R，双端队列中保证数从大到小排序，双端队列中加数的操作是由R指针向右移动的。在加数的过程中，如果R指针指向的数a小于双端队列的尾部数，那么a进队列，否则将双端队列中小于a的数从队列中弹出直到双端队列尾部的数大于a。

**窗口减数的更新逻辑**

如果L往右边走的时候，检查 L所在数的index，然后从双端队列的头部弹出index

```python
def getmaxWindow(array,w):
	"""

	:param array:
	:param w: 窗口的大小
	:return: 各个窗口的最大值
	"""
	if array is None or len(array)<w or w<1:
		return None
	length = len(array)
	#一共有n-w+1个窗口值
	res = [0]*(length-w+1)
	#准备一个双端队列
	qmax = []
	#左指针
	index=0
	for i in range(length):
		#当前数如果大于双端队列尾部的数时，双端队列尾部值弹出,直到尾部数不小于当前数为止
		while len(qmax)!=0 and array[qmax[-1]]<=array[i]:
			qmax.pop()
		qmax.append(i)
		#减数逻辑
		if qmax[0] ==i-w:
			qmax.pop(0)
		if i>=w-1:
			res[index] = array[qmax[0]]
			index+=1
	return  res

```



```
最大值减去最小值小于或等于num的子数组数量
题目：
给定数组arr和整数num,共返回有多少个子数组满足如下情况：
max(arr[i,,,,j])-min(arr[i....j])<=num
max(arr[i,,,,j])表示子数组arr[i....j]中的最大值,min(arr[i...j])表示子数组arr[i....j]中的最小值

要求实现时间复杂度为o(N)的解法


```

**暴力解法**

给定的一个arr，那么它一共有多少个子数组呢？ 答案时N平方个子数组,所以我们可以求这n平方个子数组的最小值最大值，然后校验每一个子数组的是否满足条件。